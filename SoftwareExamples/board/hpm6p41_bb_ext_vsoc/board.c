/*
 * Copyright (c) 2024,2025 HPMicro
 * SPDX-License-Identifier: BSD-3-Clause
 *
 *
 */

#include "board.h"
#include "hpm_gptmr_drv.h"
#include "hpm_gpio_drv.h"
#include "pinmux.h"
#include "hpm_pmp_drv.h"
#include "hpm_clock_drv.h"
#include "hpm_sysctl_drv.h"
#include "hpm_pllctlv2_drv.h"
#include "hpm_pcfg_drv.h"
#include "hpm_usb_drv.h"

#include "hpm_spi_drv.h"
#include "hpm_mcan_drv.h"

#include "board_i2c.h"
#include "board_syr838.h"

#include <SEGGER_RTT.h>
#include "def_rtt_printf.h"

/**
 * @brief FLASH configuration option definitions:
 * option[0]:
 *    [31:16] 0xfcf9 - FLASH configuration option tag
 *    [15:4]  0 - Reserved
 *    [3:0]   option words (exclude option[0])
 * option[1]:
 *    [31:28] Flash probe type
 *      0 - SFDP SDR / 1 - SFDP DDR
 *      2 - 1-4-4 Read (0xEB, 24-bit address) / 3 - 1-2-2 Read(0xBB, 24-bit address)
 *      4 - HyperFLASH 1.8V / 5 - HyperFLASH 3V
 *      6 - OctaBus DDR (SPI -> OPI DDR)
 *      8 - Xccela DDR (SPI -> OPI DDR)
 *      10 - EcoXiP DDR (SPI -> OPI DDR)
 *    [27:24] Command Pads after Power-on Reset
 *      0 - SPI / 1 - DPI / 2 - QPI / 3 - OPI
 *    [23:20] Command Pads after Configuring FLASH
 *      0 - SPI / 1 - DPI / 2 - QPI / 3 - OPI
 *    [19:16] Quad Enable Sequence (for the device support SFDP 1.0 only)
 *      0 - Not needed
 *      1 - QE bit is at bit 6 in Status Register 1
 *      2 - QE bit is at bit1 in Status Register 2
 *      3 - QE bit is at bit7 in Status Register 2
 *      4 - QE bit is at bit1 in Status Register 2 and should be programmed by 0x31
 *    [15:8] Dummy cycles
 *      0 - Auto-probed / detected / default value
 *      Others - User specified value, for DDR read, the dummy cycles should be 2 * cycles on FLASH datasheet
 *    [7:4] Misc.
 *      0 - Not used
 *      1 - SPI mode
 *      2 - Internal loopback
 *      3 - External DQS
 *    [3:0] Frequency option
 *      1 - 30MHz / 2 - 50MHz / 3 - 66MHz / 4 - 80MHz / 5 - 100MHz / 6 - 114MHz / 7 - 133MHz / 8 - 166MHz
 *
 * option[2] (Effective only if the bit[3:0] in option[0] > 1)
 *    [31:20]  Reserved
 *    [19:16] IO voltage
 *      0 - 3V / 1 - 1.8V
 *    [15:12] Pin group
 *      0 - 1st group / 1 - 2nd group
 *    [11:8] Connection selection
 *      0 - CA_CS0 / 1 - CB_CS0 / 2 - CA_CS0 + CB_CS0 (Two FLASH connected to CA and CB respectively)
 *    [7:0] Drive Strength
 *      0 - Default value
 * option[3] (Effective only if the bit[3:0] in option[0] > 2, required only for the QSPI NOR FLASH that not supports
 *              JESD216)
 *    [31:16] reserved
 *    [15:12] Sector Erase Command Option, not required here
 *    [11:8]  Sector Size Option, not required here
 *    [7:0] Flash Size Option
 *      0 - 4MB / 1 - 8MB / 2 - 16MB
 */
#if defined(FLASH_XIP) && FLASH_XIP
__attribute__((section(".nor_cfg_option"), used)) const uint32_t option[4] = { 0xfcf90002, 0x00000005, 0x1000, 0x0 };
#endif

#if defined(FLASH_UF2) && FLASH_UF2
ATTR_PLACE_AT(".uf2_signature") __attribute__((used)) const uint32_t uf2_signature = BOARD_UF2_SIGNATURE;
#endif

void board_init_console(void)
{
#if !defined(CONFIG_NDEBUG_CONSOLE) || !CONFIG_NDEBUG_CONSOLE
#if BOARD_CONSOLE_TYPE == CONSOLE_TYPE_UART
    console_config_t cfg;

    /* uart needs to configure pin function before enabling clock, otherwise the level change of
     * uart rx pin when configuring pin function will cause a wrong data to be received.
     * And a uart rx dma request will be generated by default uart fifo dma trigger level.
     */
    init_uart_pins((UART_Type *) BOARD_CONSOLE_UART_BASE);

    clock_add_to_group(BOARD_CONSOLE_UART_CLK_NAME, 0);

    cfg.type = BOARD_CONSOLE_TYPE;
    cfg.base = (uint32_t) BOARD_CONSOLE_UART_BASE;
    cfg.src_freq_in_hz = clock_get_frequency(BOARD_CONSOLE_UART_CLK_NAME);
    cfg.baudrate = BOARD_CONSOLE_UART_BAUDRATE;

    if (status_success != console_init(&cfg)) {
        /* failed to  initialize debug console */
        while (1) {
        }
    }
#else
    while (1)
        ;
#endif
#endif
}

void board_print_clock_freq(void)
{
    LOG("==============================\n");
    LOG(" %s clock summary\n", BOARD_NAME);
    LOG("==============================\n");
    LOG("cpu0:\t\t %dHz\n", clock_get_frequency(clock_cpu0));
    LOG("ahb:\t\t %luHz\n", clock_get_frequency(clock_ahb0));
    LOG("axif:\t\t %dHz\n", clock_get_frequency(clock_axif));
    LOG("axis:\t\t %dHz\n", clock_get_frequency(clock_axis));
    LOG("axic:\t\t %dHz\n", clock_get_frequency(clock_axic));
    LOG("xpi0:\t\t %dHz\n", clock_get_frequency(clock_xpi0));
    LOG("mchtmr0:\t %dHz\n", clock_get_frequency(clock_mchtmr0));
    LOG("==============================\n");
}

void board_init_uart(UART_Type *ptr)
{
    /* configure uart's pin before opening uart's clock */
    init_uart_pins();
    board_init_uart_clock(ptr);
}

void board_print_banner(void)
{
    const uint8_t banner[] = { "\n\
----------------------------------------------------------------------\n\
$$\\   $$\\ $$$$$$$\\  $$\\      $$\\ $$\\\n\
$$ |  $$ |$$  __$$\\ $$$\\    $$$ |\\__|\n\
$$ |  $$ |$$ |  $$ |$$$$\\  $$$$ |$$\\  $$$$$$$\\  $$$$$$\\   $$$$$$\\\n\
$$$$$$$$ |$$$$$$$  |$$\\$$\\$$ $$ |$$ |$$  _____|$$  __$$\\ $$  __$$\\\n\
$$  __$$ |$$  ____/ $$ \\$$$  $$ |$$ |$$ /      $$ |  \\__|$$ /  $$ |\n\
$$ |  $$ |$$ |      $$ |\\$  /$$ |$$ |$$ |      $$ |      $$ |  $$ |\n\
$$ |  $$ |$$ |      $$ | \\_/ $$ |$$ |\\$$$$$$$\\ $$ |      \\$$$$$$  |\n\
\\__|  \\__|\\__|      \\__|     \\__|\\__| \\_______|\\__|       \\______/\n\
----------------------------------------------------------------------\n" };
#ifdef SDK_VERSION_STRING
    LOG("hpm_sdk: %s\n", SDK_VERSION_STRING);
#endif
    LOG("%s", banner);
}

void board_ungate_mchtmr_at_lp_mode(void)
{
    /* Keep cpu clock on wfi, so that mchtmr irq can still work after wfi */
    sysctl_set_cpu_lp_mode(HPM_SYSCTL, BOARD_RUNNING_CORE, cpu_lp_mode_ungate_cpu_clock);
}

void board_init(void)
{
    board_init_clock();
    board_init_console();

#if CONFIG_NDEBUG_CONSOLE
    SEGGER_RTT_Init();
    SEGGER_RTT_ConfigUpBuffer(0, "RTT_UP", NULL, 0, SEGGER_RTT_MODE_NO_BLOCK_SKIP);
    SEGGER_RTT_ConfigDownBuffer(0, "RTT_DN", NULL, 0, SEGGER_RTT_MODE_NO_BLOCK_SKIP);
#endif

    board_init_pmp();

#if BOARD_SHOW_CLOCK
    board_print_clock_freq();
#endif
#if BOARD_SHOW_BANNER
    board_print_banner();
#endif
    board_delay_ms(10);
}

void board_delay_us(uint32_t us)
{
    clock_cpu_delay_us(us);
}

void board_delay_ms(uint32_t ms)
{
    clock_cpu_delay_ms(ms);
}

#if !defined(NO_BOARD_TIMER_SUPPORT) || !NO_BOARD_TIMER_SUPPORT
static board_timer_cb timer_cb;
SDK_DECLARE_EXT_ISR_M(BOARD_CALLBACK_TIMER_IRQ, board_timer_isr)
void board_timer_isr(void)
{
    if (gptmr_check_status(BOARD_CALLBACK_TIMER, GPTMR_CH_RLD_STAT_MASK(BOARD_CALLBACK_TIMER_CH))) {
        gptmr_clear_status(BOARD_CALLBACK_TIMER, GPTMR_CH_RLD_STAT_MASK(BOARD_CALLBACK_TIMER_CH));
        timer_cb();
    }
}

void board_timer_create(uint32_t ms, board_timer_cb cb)
{
    uint32_t gptmr_freq;
    gptmr_channel_config_t config;

    timer_cb = cb;
    gptmr_channel_get_default_config(BOARD_CALLBACK_TIMER, &config);

    clock_add_to_group(BOARD_CALLBACK_TIMER_CLK_NAME, 0);
    gptmr_freq = clock_get_frequency(BOARD_CALLBACK_TIMER_CLK_NAME);

    config.reload = gptmr_freq / 1000 * ms;
    gptmr_channel_config(BOARD_CALLBACK_TIMER, BOARD_CALLBACK_TIMER_CH, &config, false);
    gptmr_enable_irq(BOARD_CALLBACK_TIMER, GPTMR_CH_RLD_IRQ_MASK(BOARD_CALLBACK_TIMER_CH));
    intc_m_enable_irq_with_priority(BOARD_CALLBACK_TIMER_IRQ, 1);

    gptmr_start_counter(BOARD_CALLBACK_TIMER, BOARD_CALLBACK_TIMER_CH);
}
#endif

uint8_t board_get_led_pwm_off_level(void)
{
    return BOARD_LED_OFF_LEVEL;
}

uint8_t board_get_led_gpio_off_level(void)
{
    return BOARD_LED_OFF_LEVEL;
}

void board_init_led_pins(void)
{
    init_led_pins_as_gpio();
    gpio_set_pin_output_with_initial(BOARD_LED0_GPIO_CTRL, BOARD_LED0_GPIO_INDEX, BOARD_LED0_GPIO_PIN, board_get_led_gpio_off_level());
    gpio_set_pin_output_with_initial(BOARD_LED1_GPIO_CTRL, BOARD_LED1_GPIO_INDEX, BOARD_LED1_GPIO_PIN, board_get_led_gpio_off_level());
    gpio_set_pin_output_with_initial(BOARD_LED2_GPIO_CTRL, BOARD_LED2_GPIO_INDEX, BOARD_LED2_GPIO_PIN, board_get_led_gpio_off_level());
}
static volatile bool btn1_pressed = false;
static volatile bool btn2_pressed = false;
void board_init_btn(void)
{
    init_btn_pins();
    intc_m_enable_irq_with_priority(BOARD_BTN_GPIO_IRQ, 1);
}
SDK_DECLARE_EXT_ISR_M(BOARD_BTN_GPIO_IRQ, board_btn_isr)
void board_btn_isr(void){
    if(gpio_check_clear_interrupt_flag(BOARD_BTN1_GPIO_CTRL, BOARD_BTN1_GPIO_INDEX, BOARD_BTN1_GPIO_PIN) == true){
        btn1_pressed = true;
        //LOG("BTN1 pressed! \r\n");
    }
    if(gpio_check_clear_interrupt_flag(BOARD_BTN2_GPIO_CTRL, BOARD_BTN2_GPIO_INDEX, BOARD_BTN2_GPIO_PIN) == true){
        btn2_pressed = true;
        //LOG("BTN2 pressed! \r\n");
    }
}

bool board_btn1_get_stat(void){
    bool ret = btn1_pressed;
    btn1_pressed = false;
    return ret;
}

bool board_btn2_get_stat(void){
    bool ret = btn2_pressed;
    btn2_pressed = false;
    return ret;
}

void board_led0_toggle(void)
{
        gpio_toggle_pin(BOARD_LED0_GPIO_CTRL, BOARD_LED0_GPIO_INDEX, BOARD_LED0_GPIO_PIN);
}
void board_led1_toggle(void)
{
        gpio_toggle_pin(BOARD_LED1_GPIO_CTRL, BOARD_LED1_GPIO_INDEX, BOARD_LED1_GPIO_PIN);
}
void board_led2_toggle(void)
{
        gpio_toggle_pin(BOARD_LED2_GPIO_CTRL, BOARD_LED2_GPIO_INDEX, BOARD_LED2_GPIO_PIN);
}

void board_led0_write(uint8_t state)
{
    gpio_write_pin(BOARD_LED0_GPIO_CTRL, BOARD_LED0_GPIO_INDEX, BOARD_LED0_GPIO_PIN, state);
}
void board_led1_write(uint8_t state)
{
    gpio_write_pin(BOARD_LED1_GPIO_CTRL, BOARD_LED1_GPIO_INDEX, BOARD_LED1_GPIO_PIN, state);
}
void board_led2_write(uint8_t state)
{
    gpio_write_pin(BOARD_LED2_GPIO_CTRL, BOARD_LED2_GPIO_INDEX, BOARD_LED2_GPIO_PIN, state);
}

void board_init_pmp(void)
{
    uint32_t start_addr;
    uint32_t end_addr;
    uint32_t length;
    pmp_entry_t pmp_entry[16];
    uint8_t index = 0;

    /* Init noncachable memory */
    extern uint32_t __noncacheable_start__[];
    extern uint32_t __noncacheable_end__[];
    start_addr = (uint32_t) __noncacheable_start__;
    end_addr = (uint32_t) __noncacheable_end__;
    length = end_addr - start_addr;
    if (length > 0) {
        /* Ensure the address and the length are power of 2 aligned */
        assert((length & (length - 1U)) == 0U);
        assert((start_addr & (length - 1U)) == 0U);
        pmp_entry[index].pmp_addr = PMP_NAPOT_ADDR(start_addr, length);
        pmp_entry[index].pmp_cfg.val = PMP_CFG(READ_EN, WRITE_EN, EXECUTE_EN, ADDR_MATCH_NAPOT, REG_UNLOCK);
        pmp_entry[index].pma_addr = PMA_NAPOT_ADDR(start_addr, length);
        pmp_entry[index].pma_cfg.val = PMA_CFG(ADDR_MATCH_NAPOT, MEM_TYPE_MEM_NON_CACHE_BUF, AMO_EN);
        index++;
    }

    /* Init share memory */
    extern uint32_t __share_mem_start__[];
    extern uint32_t __share_mem_end__[];
    start_addr = (uint32_t)__share_mem_start__;
    end_addr = (uint32_t)__share_mem_end__;
    length = end_addr - start_addr;
    if (length > 0) {
        /* Ensure the address and the length are power of 2 aligned */
        assert((length & (length - 1U)) == 0U);
        assert((start_addr & (length - 1U)) == 0U);
        pmp_entry[index].pmp_addr = PMP_NAPOT_ADDR(start_addr, length);
        pmp_entry[index].pmp_cfg.val = PMP_CFG(READ_EN, WRITE_EN, EXECUTE_EN, ADDR_MATCH_NAPOT, REG_UNLOCK);
        pmp_entry[index].pma_addr = PMA_NAPOT_ADDR(start_addr, length);
        pmp_entry[index].pma_cfg.val = PMA_CFG(ADDR_MATCH_NAPOT, MEM_TYPE_MEM_NON_CACHE_BUF, AMO_EN);
        index++;
    }

    pmp_config(&pmp_entry[0], index);
}

void board_init_clock(void)
{
    uint32_t cpu0_freq = clock_get_frequency(clock_cpu0);
    if (cpu0_freq == PLLCTL_SOC_PLL_REFCLK_FREQ) {
        /* Configure the External OSC ramp-up time: ~9ms */
        pllctlv2_xtal_set_rampup_time(HPM_PLLCTLV2, 32ul * 1000ul * 9u);

        /* select clock setting preset1 */
        sysctl_clock_set_preset(HPM_SYSCTL, 2);
    }
    
    pcfg_dcdc_set_mode(HPM_PCFG, pcfg_dcdc_mode_off);
    pcfg_dcdc_set_voltage(HPM_PCFG, 0);

    /* Set CPU clock to 300MHz */
    clock_set_source_divider(clock_cpu0, clk_src_pll0_clk0, 2);

    /* Add Clocks to group 0 */
    clock_add_to_group(clock_cpu0, 0);
    clock_add_to_group(clock_mchtmr0, 0);
    clock_add_to_group(clock_ahb0, 0);
    clock_add_to_group(clock_axif, 0);
    clock_add_to_group(clock_axis, 0);
    clock_add_to_group(clock_axic, 0);
    clock_add_to_group(clock_rom0, 0);
    clock_add_to_group(clock_xpi0, 0);
    clock_add_to_group(clock_lmm0, 0);
    clock_add_to_group(clock_lmm1, 0);
    clock_add_to_group(clock_ram0, 0);
    clock_add_to_group(clock_hdma, 0);
    clock_add_to_group(clock_xdma, 0);
    clock_add_to_group(clock_gpio, 0);
    clock_add_to_group(clock_ptpc, 0);
    /* Motor Related */
    clock_add_to_group(clock_qei0, 0);
    clock_add_to_group(clock_qei1, 0);
    clock_add_to_group(clock_qeo0, 0);
    clock_add_to_group(clock_qeo1, 0);
    clock_add_to_group(clock_pwm0, 0);
    clock_add_to_group(clock_pwm1, 0);
    clock_add_to_group(clock_pwm2, 0);
    clock_add_to_group(clock_pwm3, 0);
    clock_add_to_group(clock_rdc0, 0);
    clock_add_to_group(clock_plb0, 0);
    clock_add_to_group(clock_sei0, 0);
    clock_add_to_group(clock_mtg0, 0);
    clock_add_to_group(clock_vsc0, 0);
    clock_add_to_group(clock_clc0, 0);
    clock_add_to_group(clock_emds, 0);
    /* Connect Group0 to CPU0 */
    clock_connect_group_to_cpu(0, 0);


    /* Configure mchtmr to 24MHz */
    clock_set_source_divider(clock_mchtmr0, clk_src_osc24m, 1);

    clock_update_core_clock();
}

void board_clock_full_speed(void){
    board_syr838_reg_i2c_context(board_get_i2c_context());
    syr838_set_vout_uv(1375000);
    board_delay_ms(30);
    //clock_set_source_divider(clock_cpu0, clk_src_pll1_clk0, 1);    /* Set CPU clock to 800MHz */
    clock_set_source_divider(clock_cpu0, clk_src_pll0_clk0, 1);    /* Set CPU clock to 600MHz */
    board_delay_ms(30);
    LOG("cpu0 ramp up to:\t : %u\r\n", clock_get_frequency(clock_cpu0));
}

uint32_t board_init_uart_clock(UART_Type *ptr)
{
    uint32_t freq = 0U;
    if (ptr == HPM_UART2) {
        clock_add_to_group(clock_uart2, 0);
        freq = clock_get_frequency(clock_uart2);
    } else {
        /* Not supported */
    }
    return freq;
}

void board_init_usb(USB_Type *ptr)
{
    if (ptr == HPM_USB0) {
        /* USB0_P */
        HPM_IOC->PAD[IOC_PAD_PD00].FUNC_CTL = IOC_PAD_FUNC_CTL_ANALOG_MASK;
        /* USB0_N */
        HPM_IOC->PAD[IOC_PAD_PD01].FUNC_CTL = IOC_PAD_FUNC_CTL_ANALOG_MASK;
        clock_add_to_group(clock_usb0, 0);

        usb_hcd_set_power_ctrl_polarity(ptr, true);
        /* Wait USB_PWR pin control vbus power stable. Time depend on decoupling capacitor, you can decrease or increase this time */
        board_delay_ms(100);
    }
}

spi_timing_config_t lcd_spi_timing_config   = {0};
spi_format_config_t lcd_spi_format          = {0};
spi_control_config_t lcd_spi_control_config = {0};

void board_lcd_init_spi(void) {
  uint32_t spi_clcok;

  clock_add_to_group(clock_spi0, 0);
  spi_clcok = clock_get_frequency(clock_spi0);
  lcd_init_pins();

  /* set SPI sclk frequency for master */
  spi_master_get_default_timing_config(&lcd_spi_timing_config);
  lcd_spi_timing_config.master_config.clk_src_freq_in_hz = spi_clcok;
  lcd_spi_timing_config.master_config.sclk_freq_in_hz    = BOARD_LCD_SPI_FRQ;
  if (status_success != spi_master_timing_init(BOARD_LCD_SPI, &lcd_spi_timing_config)) {
    LOG("SPI master timming init failed\n");
    while (1) {
    }
  }
  LOG("SPI-Master transfer source clock frequency: %dHz\n", lcd_spi_timing_config.master_config.clk_src_freq_in_hz);
  LOG("SPI-Master transfer sclk frequency: %dHz\n", lcd_spi_timing_config.master_config.sclk_freq_in_hz);

  /* set SPI format config for master */
  spi_master_get_default_format_config(&lcd_spi_format);
  lcd_spi_format.common_config.data_len_in_bits = 8;
  lcd_spi_format.common_config.mode             = spi_master_mode;
  lcd_spi_format.common_config.cpol             = spi_sclk_low_idle;
  lcd_spi_format.common_config.cpha             = spi_sclk_sampling_odd_clk_edges;
  spi_format_init(BOARD_LCD_SPI, &lcd_spi_format);

  /* set SPI control config for master */
  spi_master_get_default_control_config(&lcd_spi_control_config);
  lcd_spi_control_config.master_config.cmd_enable  = false; /* cmd phase control for master */
  lcd_spi_control_config.master_config.addr_enable = false; /* address phase control for master */
  lcd_spi_control_config.common_config.trans_mode  = spi_trans_write_only;
  lcd_spi_control_config.common_config.cs_index    = spi_cs_3;
}

uint32_t board_init_can_clock(void)
{
    uint32_t freq = 0;
    /* Set the CAN1 peripheral clock to 80MHz */
    clock_add_to_group(clock_can1, 0);
    clock_set_source_divider(clock_can1, clk_src_pll1_clk0, 10);
    freq = clock_get_frequency(clock_can1);
    return freq;
}

ATTR_PLACE_AT(".ahb_sram") uint32_t mcan1_msg_buf[MCAN_MSG_BUF_SIZE_IN_WORDS];
uint32_t board_init_can(void)
{
    mcan_config_t can_config;

    init_can_pins();
    uint32_t can_src_clk_freq = board_init_can_clock();

    MCAN_Type *base = BOARD_APP_CAN_BASE;
    mcan_msg_buf_attr_t attr = { (uint32_t)mcan1_msg_buf, sizeof(mcan1_msg_buf) };
    hpm_stat_t status = mcan_set_msg_buf_attr(base, &attr);
    if (status != status_success) {
        LOG("Error was detected during setting message buffer attribute, please check the arguments\n");
        }
    
    mcan_get_default_config(BOARD_APP_CAN_BASE, &can_config);
    status = mcan_init(BOARD_APP_CAN_BASE, &can_config, can_src_clk_freq);
    assert(status == status_success);
  
    return can_src_clk_freq;
}